//This source code is generated by UI Designer Studio.

#include "PrjInc.h"
#include "UIWnd/UIFlow.h"
#include "UIFlowWndMovieRes.c"
#include "UIFlowWndMovie.h"
#include "GxStrg.h"
#if(defined(_NVT_ETHREARCAM_RX_))
#include "UIApp/Network/EthCamAppSocket.h"
#endif
#if (USE_DCF == ENABLE)
#include "DCF.h"
#endif

//---------------------UIFlowWndMovieCtrl Debug Definition -----------------------------
#define __MODULE__          UIFlowWndMovie
#define __DBGLVL__          2 // 0=FATAL, 1=ERR, 2=WRN, 3=UNIT, 4=FUNC, 5=IND, 6=MSG, 7=VALUE, 8=USER
#define __DBGFLT__          "*" //*=All, [mark]=CustomClass
#include <kwrap/debug.h>

//---------------------UIFlowWndMovieCtrl Global Variables -----------------------------

//---------------------UIFlowWndMovieCtrl Prototype Declaration  -----------------------

//---------------------UIFlowWndMovieCtrl Public API  ----------------------------------

//---------------------UIFlowWndMovieCtrl Private API  ---------------------------------
//---------------------UIFlowWndMovieCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie)
CTRL_LIST_ITEM(UIFlowWndMovie_Panel_Normal_Display)
CTRL_LIST_ITEM(UIFlowWndMovie_ADAS_Alert_Display)
CTRL_LIST_END

//----------------------UIFlowWndMovieCtrl Event---------------------------
INT32 UIFlowWndMovie_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMenu(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyDown(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFinish(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieWrError(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageSlow(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnEMRCompleted(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBackgroundDone(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageInit(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndMovie)
EVENT_ITEM(NVTEVT_OPEN_WINDOW,UIFlowWndMovie_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW,UIFlowWndMovie_OnClose)
EVENT_ITEM(NVTEVT_KEY_SELECT,UIFlowWndMovie_OnKeyMenu)
EVENT_ITEM(NVTEVT_KEY_NEXT,UIFlowWndMovie_OnKeyDown)
EVENT_ITEM(NVTEVT_KEY_MENU,UIFlowWndMovie_OnKeyMenu)
EVENT_ITEM(NVTEVT_KEY_ENTER,UIFlowWndMovie_OnKeyEnter)
EVENT_ITEM(NVTEVT_KEY_DOWN,UIFlowWndMovie_OnKeyDown)
EVENT_ITEM(NVTEVT_CHILD_CLOSE,UIFlowWndMovie_OnChildClose)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2,UIFlowWndMovie_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN,UIFlowWndMovie_OnKeyZoomin)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT,UIFlowWndMovie_OnKeyZoomout)
EVENT_ITEM(NVTEVT_KEY_UP,UIFlowWndMovie_OnKeyUp)
EVENT_ITEM(NVTEVT_BATTERY,UIFlowWndMovie_OnBattery)
EVENT_ITEM(NVTEVT_KEY_MODE,UIFlowWndMovie_OnKeyMode)
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_FINISH,UIFlowWndMovie_OnMovieFinish)
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_ONE_SEC,UIFlowWndMovie_OnMovieOneSec)
EVENT_ITEM(NVTEVT_CB_MOVIE_FULL,UIFlowWndMovie_OnMovieFull)
EVENT_ITEM(NVTEVT_CB_MOVIE_WR_ERROR, UIFlowWndMovie_OnMovieWrError)
EVENT_ITEM(NVTEVT_CB_MOVIE_SLOW, UIFlowWndMovie_OnStorageSlow)
EVENT_ITEM(NVTEVT_CB_EMR_COMPLETED, UIFlowWndMovie_OnEMRCompleted)
EVENT_ITEM(NVTEVT_CB_OZOOMSTEPCHG,UIFlowWndMovie_OnOZoomStepChange)
EVENT_ITEM(NVTEVT_CB_DZOOMSTEPCHG,UIFlowWndMovie_OnDZoomStepChange)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE,UIFlowWndMovie_OnStorageChange)
EVENT_ITEM(NVTEVT_TIMER,UIFlowWndMovie_OnTimer)
EVENT_ITEM(NVTEVT_BACKGROUND_DONE, UIFlowWndMovie_OnBackgroundDone)
EVENT_ITEM(NVTEVT_STORAGE_INIT, UIFlowWndMovie_OnStorageInit)
EVENT_END


static UINT32  gUIMotionDetTimerID = NULL_TIMER;
static UINT32  g_uiDateTimerID = NULL_TIMER;
static UINT32  g_UIStopRecTimerID = NULL_TIMER;

static BOOL    g_uiRecordIngMotionDet = TRUE;

INT32 UIFlowWndMovie_OnExeRecord(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32 uiKeyAct;
	UINT32 uiState;

	if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE) {
		if (System_GetState(SYS_STATE_CARD)  == CARD_REMOVED) {
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_2SEC);
			return NVTEVT_CONSUME;
		}
	} else if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_NORMAL) {
		if (GxStrg_GetDeviceCtrl(0, CARD_READONLY)) { // card lock
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED, FLOWWRNMSG_TIMER_2SEC);
			return NVTEVT_CONSUME;
		}

		if (!GxStrg_GetDeviceCtrl(0, CARD_INSERT)) { // card insert
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_2SEC);
			return NVTEVT_CONSUME;
		}
	}

	if (paramNum >= 3) {
		uiState = paramArray[2];
	} else {
		uiState = 0;
	}

	uiKeyAct = paramNum ? paramArray[0] : 0;

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:

		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_VIEW | MOV_ST_ZOOM:
			g_uiRecordIngMotionDet = (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON) ? TRUE : FALSE;
			FlowMovie_StartRec();
			gMovData.State = MOV_ST_REC;
            GxPower_SetControl(GXPWR_CTRL_AUTOPOWEROFF_EN, FALSE);
			break;

		case MOV_ST_REC:
		case MOV_ST_REC | MOV_ST_ZOOM:
			FlowMovie_StopRec();
			FlowMovie_UpdateIcons(TRUE);
			gMovData.State = MOV_ST_VIEW;
            GxPower_SetControl(GXPWR_CTRL_AUTOPOWEROFF_EN,TRUE);

			if (uiState == UIFlowWndMovie_Restart_Rec) {
				#if (1)//defined(_KEY_METHOD_4KEY_)
				Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
				#else
				Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
				#endif
			} else {
				if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON) {
					if (g_uiRecordIngMotionDet == TRUE) {
						g_uiRecordIngMotionDet = FALSE;
						UI_SetData(FL_MOVIE_MOTION_DET, MOVIE_MOTIONDET_OFF);
						FlowMovie_IconHideMotionDet(&UIFlowWndMovie_Status_MotionDetCtrl);
					}
				}
			}
			break;
		}
	}

	return NVTEVT_CONSUME;
}

void UIFlowWndMovie_Initparam(void)
{
#if(PHOTO_MODE==ENABLE)
	// The same effect as Photo mode
	Ux_SendEvent(&CustomPhotoObjCtrl,	NVTEVT_EXE_WB,					1,	SysGetFlag(FL_WB));

	// The other settings
	Ux_SendEvent(&CustomPhotoObjCtrl,	NVTEVT_EXE_COLOR,				1,	MOVIE_COLOR_NORMAL);
#endif
	/* Video resolution setting must be set after other IQ settings */
	//Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIESIZE,			1,	SysGetFlag(FL_MOVIE_SIZE));

	/* Cyclic recording/record with mute or sound/DateImptint/Motion Detect */
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_CYCLIC_REC,			1,	SysGetFlag(FL_MOVIE_CYCLIC_REC));
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOTION_DET,			1,	SysGetFlag(FL_MOVIE_MOTION_DET));
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIE_DATE_IMPRINT,	1,	SysGetFlag(FL_MOVIE_DATEIMPRINT));
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIE_AUDIO,			1,	SysGetFlag(FL_MOVIE_AUDIO));
#if(PHOTO_MODE==ENABLE)
	Ux_SendEvent(&CustomPhotoObjCtrl,	NVTEVT_EXE_EV,					1,	SysGetFlag(FL_EV));
#endif
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIE_MCTF,			1,	SysGetFlag(FL_MovieMCTFIndex));
	//Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIE_WDR,			1,	SysGetFlag(FL_MOVIE_WDR));
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIE_HDR,			1,	SysGetFlag(FL_MOVIE_HDR));
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIE_DEFOG,			1,	SysGetFlag(FL_MOVIE_DEFOG));
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_GSENSOR,				1,	SysGetFlag(FL_GSENSOR));
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIE_SENSOR_ROTATE,	1,	SysGetFlag(FL_MOVIE_SENSOR_ROTATE));
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIE_IR_CUT,		1,	SysGetFlag(FL_MOVIE_IR_CUT));
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIE_PROTECT_AUTO,	1,	SysGetFlag(FL_MOVIE_URGENT_PROTECT_AUTO));
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIE_PROTECT_MANUAL,	1,	SysGetFlag(FL_MOVIE_URGENT_PROTECT_MANUAL));
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIE_LDWS,			1,	SysGetFlag(FL_MOVIE_LDWS));
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIE_FCW,			1,	SysGetFlag(FL_MOVIE_FCW));
	Ux_SendEvent(&UISetupObjCtrl,		NVTEVT_EXE_FREQ,				1,	SysGetFlag(FL_FREQUENCY));
#if (MOVIE_RSC == ENABLE)
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIE_RSC,			1,	MOVIE_RSC_ON);
#endif
#if MOVIE_DIS
	Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_MOVIEDIS,			1,	MOVIE_DIS_ON);
#endif
#if SHDR_FUNC
	//Ux_SendEvent(&CustomMovieObjCtrl,	NVTEVT_EXE_SHDR,				1,	MOVIE_HDR_ON);
#endif
	Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_CODEC, 1, SysGetFlag(FL_MOVIE_CODEC));
}

INT32 UIFlowWndMovie_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, FALSE);
	UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, TRUE);

	UIFlowWndMovie_Initparam();

	// Enable Motion Detect function in starting up movie mode
	if (gUIMotionDetTimerID == NULL_TIMER) {
		gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
	}
	g_uiRecordIngMotionDet = (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON) ? TRUE : FALSE;

	if (g_uiDateTimerID == NULL_TIMER) {
		g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
	}

	gMovData.State = MOV_ST_VIEW;
	Ux_DefaultEvent(pCtrl,NVTEVT_OPEN_WINDOW,paramNum,paramArray);
	FlowMovie_UpdateIcons(TRUE);

	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	if (g_uiDateTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&g_uiDateTimerID);
	}
	if (gUIMotionDetTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&gUIMotionDetTimerID);
	}

	Ux_DefaultEvent(pCtrl,NVTEVT_CLOSE_WINDOW,paramNum,paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    DBG_FUNC_BEGIN("\r\n");
	UINT32  uiKeyAct;
	UINT32  uiSoundMask;

	uiKeyAct = paramArray[0];

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_VIEW|MOV_ST_ZOOM:
			// stop timer when entering menu
			if (gUIMotionDetTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&gUIMotionDetTimerID);
			}

			if (g_uiDateTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&g_uiDateTimerID);
			}

			if (g_UIStopRecTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&g_UIStopRecTimerID);
			}
			// enable shutter2 sound (shutter2 as OK key in menu)
			uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
			uiSoundMask |= FLGKEY_ENTER;
			Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);
			Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);

			// Open common mix (Item + Option) menu
			Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
			gMovData.State = MOV_ST_MENU;
			break;

		case MOV_ST_REC:
		case MOV_ST_REC|MOV_ST_ZOOM:
			if (SysGetFlag(FL_MOVIE_URGENT_PROTECT_MANUAL) == MOVIE_URGENT_PROTECT_MANUAL_ON) {
				#if (_BOARD_DRAM_SIZE_ > 0x04000000)
				if (GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE)) == MOVIE_REC_TYPE_FRONT) {
#if(defined(_NVT_ETHREARCAM_RX_))
					ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1, TRUE);
					UINT32 i;
					for (i = 0; i < ETH_REARCAM_CAPS_COUNT; i++) {
						if(socketCliEthData1_IsRecv(ETHCAM_PATH_ID_1 +i)){
							ImageApp_MovieMulti_SetCrash(_CFG_ETHCAM_ID_1+i, TRUE);
						}
					}
#else
					if(gMovie_Rec_Option.emr_on == _CFG_EMR_SET_CRASH){
						ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1, TRUE);
					}else{
						ImageApp_MovieMulti_TrigEMR(_CFG_REC_ID_1);
					}
#endif
				} else
				#endif
				{
					UINT32 i, mask, movie_rec_mask;

					movie_rec_mask = Movie_GetMovieRecMask();
					mask = 1;
					for (i = 0; i < SENSOR_CAPS_COUNT; i++) {
						if (movie_rec_mask & mask) {
							ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1 + i, TRUE);
						}
						mask <<= 1;
					}
				}
				Ux_DefaultEvent(pCtrl, NVTEVT_KEY_NEXT, paramNum, paramArray);
				return NVTEVT_CONSUME;
			}
			break;
		}
		break;
	}

	Ux_DefaultEvent(pCtrl, NVTEVT_KEY_MENU, paramNum, paramArray);
    DBG_FUNC_END("\r\n");
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyEnter(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	Ux_DefaultEvent(pCtrl,NVTEVT_KEY_ENTER,paramNum,paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;

	uiKeyAct = paramArray[0];

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		switch (gMovData.State) {
		case MOV_ST_REC:
		case MOV_ST_REC|MOV_ST_ZOOM:
			if (SysGetFlag(FL_MOVIE_PIM) == MOVIE_PIM_ON) {
				FlowMovie_DrawPIM(TRUE);
				Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 0);
			}
			break;
		}
		break;
	}
	Ux_DefaultEvent(pCtrl,NVTEVT_KEY_DOWN,paramNum,paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	switch (gMovData.State) {
	case MOV_ST_WARNING_MENU:
		if (paramNum > 0) {
			if (paramArray[0] == NVTRET_ENTER_MENU) {
				/* Create Menu window */
				gMovData.State = MOV_ST_MENU;
				Ux_OpenWindow(&MenuCommonItemCtrl, 0);
				return NVTEVT_CONSUME;
			}
		}
		gMovData.State = MOV_ST_VIEW;
		break;

	case MOV_ST_MENU:
		#if _TODO
		// disable shutter2 sound
		uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
		uiSoundMask &= ~FLGKEY_ENTER;
		Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

		g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
		g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
		Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
		Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyRelease);
		#endif
		FlowMovie_UpdateIcons(TRUE);

		// start timer again when exiting menu
		if (gUIMotionDetTimerID == NULL_TIMER) {
			gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
		}
		// Enable Motion Detect function in starting up movie mode
		g_uiRecordIngMotionDet = (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON) ? TRUE : FALSE;

		if (g_uiDateTimerID == NULL_TIMER) {
			g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
		}

		gMovData.State = MOV_ST_VIEW;
		break;

	case MOV_ST_VIEW:
		if (paramNum > 0) {
			if ((paramNum == 2) && (paramArray[0] == NVTRET_WAITMOMENT)) {
				if (paramArray[1] == NVTRET_RESTART_REC) {
					#if defined(_KEY_METHOD_4KEY_)
					Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
					#else
					Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
					#endif
				} else {
					FlowMovie_UpdateIcons(TRUE);
				}
			}
		}
		break;
	}

	//#NT#2018/08/10#KCHong -begin
	//#NT#Fixed Jira NA51000-1230
	if (gMovData.State == MOV_ST_VIEW || gMovData.State == MOV_ST_REC) {
		FlowMovie_UpdateIcons(TRUE);
		if (ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_1)
#if(SENSOR_CAPS_COUNT >=2)
			|| ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_2)
#endif
		) {
			gMovData.State = MOV_ST_REC;
		} else {
			gMovData.State = MOV_ST_VIEW;
		}
	}
	//#NT#2018/08/10#KCHong -end

	Ux_DefaultEvent(pCtrl,NVTEVT_CHILD_CLOSE,paramNum,paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UIFlowWndMovie_OnExeRecord(pCtrl, paramNum, paramArray);
	Ux_DefaultEvent(pCtrl,NVTEVT_KEY_SHUTTER2,paramNum,paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnExeZoomIn(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if(PHOTO_MODE==ENABLE)
	UINT32  uiKeyAct;
	uiKeyAct = paramNum ? paramArray[0] : 0;

	debug_ind(("[UIFlowWndMovie_OnExeZoomIn][%d]\n\r", uiKeyAct));

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
	case NVTEVT_KEY_CONTINUE:
		if (0) { //((Photo_GetDZoomIdx()-10) > UI_DZOOM_IDX_MAX)
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
			gMovData.State &= ~MOV_ST_ZOOM;
			return NVTEVT_PASS;
		}
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_REC:
		case MOV_ST_VIEW | MOV_ST_ZOOM:
		case MOV_ST_REC | MOV_ST_ZOOM:
			/* set Digital Zoom interface */
			UI_SetData(FL_ZoomIFIndex, ZOOM_IF_DIGITAL);

			gMovData.State |= MOV_ST_ZOOM;
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 1, UI_ZOOM_CTRL_IN);
			//Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_IN, UI_GetData(FL_Dzoom));
			break;
		}
		break;

	case NVTEVT_KEY_RELEASE:
		switch (gMovData.State) {
		case MOV_ST_VIEW | MOV_ST_ZOOM:
		case MOV_ST_REC | MOV_ST_ZOOM:
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 1, UI_ZOOM_CTRL_STOP);
			//Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
			gMovData.State &= ~MOV_ST_ZOOM;
			break;
		}
		break;
	}
#endif
	return NVTEVT_PASS;
}

INT32 UIFlowWndMovie_OnExeZoomOut(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if(PHOTO_MODE==ENABLE)
	UINT32  uiKeyAct;

	uiKeyAct = paramNum ? paramArray[0] : 0;

	debug_ind(("[UIFlowWndMovie_OnExeZoomOut][%d]\n\r", uiKeyAct));

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
	case NVTEVT_KEY_CONTINUE:
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_REC:
		case MOV_ST_VIEW | MOV_ST_ZOOM:
		case MOV_ST_REC | MOV_ST_ZOOM:
			/* set Digital Zoom interface */
			CHKPNT;
			UI_SetData(FL_ZoomIFIndex, ZOOM_IF_DIGITAL);

			gMovData.State |= MOV_ST_ZOOM;
			//Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_OUT, UI_GetData(FL_Dzoom));
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 1, UI_ZOOM_CTRL_OUT);
			break;
		}
		break;

	case NVTEVT_KEY_RELEASE:
		switch (gMovData.State) {
		case MOV_ST_VIEW | MOV_ST_ZOOM:
		case MOV_ST_REC | MOV_ST_ZOOM:
			//Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 1, UI_ZOOM_CTRL_STOP);
			gMovData.State &= ~MOV_ST_ZOOM;
			break;
		}
		break;
	}
#endif
	return NVTEVT_PASS;
}
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndMovie_OnExeZoomIn(pCtrl, paramNum, paramArray);
	//Ux_DefaultEvent(pCtrl,NVTEVT_KEY_ZOOMIN,paramNum,paramArray);
	//return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndMovie_OnExeZoomOut(pCtrl, paramNum, paramArray);
	//Ux_DefaultEvent(pCtrl,NVTEVT_KEY_ZOOMOUT,paramNum,paramArray);
	//return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	Ux_DefaultEvent(pCtrl,NVTEVT_KEY_UP,paramNum,paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnMovieFinish(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	switch (gMovData.State) {
	case MOV_ST_REC:
	case MOV_ST_REC|MOV_ST_ZOOM:
		if (paramNum) {
			if (UxState_GetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM) == UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT) {
				UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_ELLIPSE);
			} else {
				UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT);
			}
			FlowMovie_IconHideMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
			FlowMovie_SetRecCurrTime(paramArray[0]);
			FlowMovie_IconDrawRecTime(&UIFlowWndMovie_Static_timeCtrl);
		}
		if (UxCtrl_IsShow(&UIFlowWndMovie_StaticIcon_PIMCCtrl)) {
			FlowMovie_DrawPIM(FALSE);
		}
		break;
	}

	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnMovieFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	FlowMovie_StopRec();
	////KeyScan_EnableMisc(TRUE);
	gMovData.State = MOV_ST_WARNING_MENU;
	Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL, FLOWWRNMSG_TIMER_2SEC);
	FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnMovieWrError(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	if ((gMovData.State == MOV_ST_REC) || (gMovData.State == (MOV_ST_REC | MOV_ST_ZOOM))) {
		FlowMovie_StopRec();
		if (System_GetState(SYS_STATE_CARD)  == CARD_LOCKED) {
			gMovData.State = MOV_ST_WARNING_MENU;
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED, FLOWWRNMSG_TIMER_3SEC);
			return NVTEVT_CONSUME;
		} else {
			gMovData.State = MOV_ST_WARNING_MENU;
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_MEMORYERROR, FLOWWRNMSG_TIMER_3SEC);
			return NVTEVT_CONSUME;
		}
	} else {
		//Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
	}
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	// trigger re-start encoding
#if (1)//defined(_KEY_METHOD_4KEY_)
	Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#else
	Ux_PostEvent(NVTEVT_KEY_SELECT, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#endif
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnEMRCompleted(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (__DBGLVL__ >= 6)
	UINT32  uiPathId = 0;

	if (paramNum)
	{
		uiPathId = paramArray[0];
	}

	DBG_IND("EMR(%d) completed!\r\n", uiPathId);
#endif
	if((paramNum == 2)&&(paramArray[1] == MOVIE_USER_CB_EVENT_EMR_FILE_COMPLETED))
	{
		DBG_IND("EMR(%d) completed!\r\n", uiPathId);
	}
	else if((paramNum == 2)&&(paramArray[1] == MOVIE_USER_CB_EVENT_CARSH_FILE_COMPLETED))
	{
		DBG_IND("Crash (%d) completed!\r\n", uiPathId);
	}
	else if((paramNum == 2)&&(paramArray[1] == MOVIE_USER_CB_EVENT_PREV_CARSH_FILE_COMPLETED))
	{
		DBG_IND("Crash (%d) completed!\r\n", uiPathId);
	}

	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}

static void UIFlowWndMovie_OnMotionDetect(void)
{
	static UINT32  uiMotionDetGo = 0;
	static UINT32  uiMotionDetStop = 0;
	static BOOL    bMotionDetRec = FALSE; // TRUE: trigger record by MD
	static UINT32  uiMotionDetRet = 0;
	Ux_SendEvent(0, NVTEVT_EXE_MOTION_DET_RUN, 1, (UINT32)&uiMotionDetRet);

	if (uiMotionDetRet == TRUE)	{
		uiMotionDetGo++;
		if (uiMotionDetGo >= 2) {
			uiMotionDetStop = 0;
			// Recording of modtion detection in pure CarDV path
			if (!((gMovData.State == MOV_ST_REC) || (gMovData.State == (MOV_ST_REC | MOV_ST_ZOOM)))) {
				// reset uiMotionDetGo
				uiMotionDetGo = 0;
				bMotionDetRec = TRUE;
				// press key to record video
#if (1) //defined(_KEY_METHOD_4KEY_)
				Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#else
				Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
#endif
			}
		}
	} else {
		if (bMotionDetRec == TRUE) {
			uiMotionDetStop++;
			if (uiMotionDetStop >= 2) { // 1 sec
				uiMotionDetGo = 0;
			}
			if (uiMotionDetStop >= 20) { // 10 Sec
				uiMotionDetStop = 0;
				if (FlowMovie_GetRecCurrTime() >= 1) {
					if (gMovData.State == MOV_ST_REC || gMovData.State == (MOV_ST_REC | MOV_ST_ZOOM)) {
						FlowMovie_StopRec();
						// update ui window icon
						FlowMovie_UpdateIcons(TRUE);
						bMotionDetRec = FALSE;
					}
				}
			}
		}
	}
}

INT32 UIFlowWndMovie_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiEvent;
	#if (ETH_POWER_DOWN==ENABLE)
    static BOOL bFirstEntry = TRUE;
    #endif

	uiEvent = paramNum ? paramArray[0] : 0;

	switch (uiEvent) {
   	case NVTEVT_01SEC_TIMER:
		#if _TODO
       	if(g_uiRecStopTimerCnt){
       	    g_uiRecStopTimerCnt--;
       	    if(g_uiRecStopTimerCnt==0){
       	        if (g_UIStopRecTimerID != NULL_TIMER) {
               		GxTimer_StopTimer(&g_UIStopRecTimerID);
       	        }
       	        Ux_OpenWindow(&UIFlowWndWaitMomentCtrl, 1, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_STOPREC_WAIT);
       	        break;
       	    }
       	}
		#endif
   	    break;

	case NVTEVT_05SEC_TIMER:
		// Do Motion detect process
		if (g_uiRecordIngMotionDet == TRUE) {
			UIFlowWndMovie_OnMotionDetect();
		}
		break;

	case NVTEVT_1SEC_TIMER:
		FlowMovie_OnTimer1SecIndex();
     	#if (ETH_POWER_DOWN==ENABLE)
        if (bFirstEntry) {
            bFirstEntry = FALSE;
        	system("mem w 0xF02B3AE8 0x01");
        	system("mem w 0xF02B3AE0 0x11");
        	system("mem w 0xF02B38DC 0x01");
        	system("mem w 0xF02B389C 0x33");
        	system("mem w 0xF02B38CC 0xA5");
        	system("mem w 0xF02B388C 0x11");
        	system("mem w 0xF02B38C8 0x01");
        	system("mem w 0xF02B3888 0x08");
        	system("mem w 0xF02B38C8 0x03");
        	system("mem w 0xF02B3888 0x08");
        	system("mem w 0xF02B38F8 0x61");
        }
    	#endif
		break;
	}

	Ux_DefaultEvent(pCtrl,NVTEVT_TIMER,paramNum,paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnBackgroundDone(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	NVTEVT event=paramArray[ONDONE_PARAM_INDEX_CMD];
	//UINT32 status= paramArray[ONDONE_PARAM_INDEX_RET];

	DBG_FUNC("event = 0x%x\r\n", event);

	switch (event) {
	case NVTEVT_BKW_STOPREC_PROCESS: {
		    //Elvis  to do g_uiRecStopTimerCnt=0;
		    FlowMovie_UpdateIcons(TRUE);

		}
		break;
	default:
		break;
	}

	return NVTEVT_CONSUME;

}

INT32 UIFlowWndMovie_OnStorageInit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
//---------------------UIFlowWndMovie_Panel_Normal_DisplayCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Panel_Normal_Display)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_camera)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_CyclicRec)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_MotionDet)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_battery)
CTRL_LIST_ITEM(UIFlowWndMovie_YMD_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_REC)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Storage)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_time)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_maxtime)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_resolution)
CTRL_LIST_ITEM(UIFlowWndMovie_Zoom_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_EV)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_HDR)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_WIFI)
CTRL_LIST_ITEM(UIFlowWndMovie_StaticIcon_PIMC)
CTRL_LIST_ITEM(UIFlowWndMovie_ADAS_DrawingLine)
///#NT#2016/06/08#Lincy Lin -begin
//#NT#Implement generic OSD and video drawing mechanism for ALG function
CTRL_LIST_ITEM(UIFlowWndMovie_ALG_Draw)
//#NT#2016/06/08#Lincy Lin -end
CTRL_LIST_END

//----------------------UIFlowWndMovie_Panel_Normal_DisplayCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Panel_Normal_Display)
EVENT_END

//----------------------UIFlowWndMovie_Static_cameraCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_camera)
EVENT_END

//----------------------UIFlowWndMovie_Status_CyclicRecCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_CyclicRec)
EVENT_END

//----------------------UIFlowWndMovie_Status_MotionDetCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_MotionDet)
EVENT_END

//----------------------UIFlowWndMovie_Status_batteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_battery)
EVENT_END

//----------------------UIFlowWndMovie_YMD_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_YMD_Static)
EVENT_END

//----------------------UIFlowWndMovie_HMS_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Static)
EVENT_END

//----------------------UIFlowWndMovie_Status_RECCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_REC)
EVENT_END

//----------------------UIFlowWndMovie_Status_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Storage)
EVENT_END

//----------------------UIFlowWndMovie_Static_timeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_time)
EVENT_END

//----------------------UIFlowWndMovie_Static_maxtimeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_maxtime)
EVENT_END

//----------------------UIFlowWndMovie_Static_resolutionCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_resolution)
EVENT_END

//----------------------UIFlowWndMovie_Zoom_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Zoom_Static)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndMovie_Status_HDRCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_HDR)
EVENT_END

//----------------------UIFlowWndMovie_Status_WIFICtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_WIFI)
EVENT_END

//----------------------UIFlowWndMovie_StaticIcon_PIMCCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StaticIcon_PIMC)
EVENT_END

//#NT#2016/06/08#Lincy Lin -begin
//#NT#Implement generic OSD and video drawing mechanism for ALG function

//---------------------UIFlowWndMovie_ADAS_DrawingLineCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_ADAS_DrawingLine)
CTRL_LIST_END

//----------------------UIFlowWndMovie_ADAS_DrawingLineCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_ADAS_DrawingLine)
EVENT_END

//---------------------UIFlowWndMovie_ALG_DrawCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_ALG_Draw)
CTRL_LIST_END
//----------------------UIFlowWndMovie_ALG_DrawCtrl Event---------------------------
#if 0
INT32 UIFlowWndMovie_ALG_Draw_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndMovie_ALG_Draw)
EVENT_ITEM(NVTEVT_REDRAW, UIFlowWndMovie_ALG_Draw_OnRedraw)
EVENT_END

INT32 UIFlowWndMovie_ALG_Draw_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_ALG_Draw_OSD(pCtrl, paramNum, paramArray);
}
#else
EVENT_BEGIN(UIFlowWndMovie_ALG_Draw)
EVENT_END
#endif
//---------------------UIFlowWndMovie_ADAS_Alert_DisplayCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_ADAS_Alert_Display)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_LDWS_Alert)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_FCWS_Alert)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_SNG_Alert)
CTRL_LIST_END

//----------------------UIFlowWndMovie_ADAS_Alert_DisplayCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_ADAS_Alert_Display)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_LDWS_AlertCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_LDWS_Alert)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_FCWS_AlertCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_FCWS_Alert)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_SNG_AlertCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_SNG_Alert)
EVENT_END

