//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "NVTToolCommand.h"
#include "UIWnd/UIFlow.h"
#include "UIWnd/SPORTCAM/UIFlow/UIFlowPlay/UIFlowWndPlayRes.c"
#include "PlaybackTsk.h"
#include "ImageApp/ImageApp_Play.h"
#include "ImageApp/ImageApp_MoviePlay.h"
#include "UIApp/Play/UIAppMoviePlay.h"
#include "FileDB.h"
#define FLOW_MOV_PLAY_REAET		DISABLE
#if (FLOW_MOV_PLAY_REAET == ENABLE)
#include "kwrap/util.h"
#endif
#include "UIApp/Play/UIPlayComm.h"

#define THIS_DBGLVL         2 // 0=FATAL, 1=ERR, 2=WRN, 3=UNIT, 4=FUNC, 5=IND, 6=MSG, 7=VALUE, 8=USER
///////////////////////////////////////////////////////////////////////////////
#if _TODO
#define __MODULE__          UIFlowWndPlay
#define __DBGLVL__          ((THIS_DBGLVL>=PRJ_DBG_LVL)?THIS_DBGLVL:PRJ_DBG_LVL)
#define __DBGFLT__          "*" //*=All, [mark]=CustomClass
#include <kwrap/debug.h>
#endif
///////////////////////////////////////////////////////////////////////////////

#if _TODO
UINT32         g_uiUIFlowWndPlayCurrentVolume   = AUDIO_VOL_5;
UINT32         g_uiUIFlowWndPlayCurrenSpeed     = SMEDIAPLAY_SPEED_NORMAL;
UINT32         g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_FORWARD;
MOVIEPLAY_FILEPLAY_INFO gMovie_Play_Info        = {0};
FST_FILE       gphUIFlowMovPlay_Filehdl         = NULL;

MOVIEPLAY_DISP_INFO  gUIFlowWndPlayDispConfig[4] = {
    //enable  disp_id       w     h      ratio     rotate dir
	{TRUE, MOVIEPLAY_DISP_ID_1, 960,  240  ,  4 ,  3  ,  0},
	{TRUE, MOVIEPLAY_DISP_ID_2, 960,  240  ,  4 ,  3  ,  0},
	{TRUE, MOVIEPLAY_DISP_ID_3, 960,  240  ,  4 ,  3  ,  0},
	{TRUE, MOVIEPLAY_DISP_ID_4, 960,  240  ,  4 ,  3  ,  0},
};


//---------------------UIFlowWndPlayCtrl Function ---------------------------
void UIFlowMoviePlay_SetSpeed(INT16 uiChangeSpeedLevel);
void UIFlowWndPlay_ConfigDispInfo(void);
#else
#define PLAY_KEY_PRESS_MASK        (FLGKEY_KEY_MASK_DEFAULT)
#define PLAY_KEY_RELEASE_MASK      FLGKEY_KEY_MASK_NULL//(FLGKEY_UP | FLGKEY_DOWN | FLGKEY_LEFT | FLGKEY_RIGHT)
#define PLAY_KEY_CONTINUE_MASK     FLGKEY_KEY_CONT_MASK_DEFAULT
#define FULL_FILE_PATH_LEN      64
#define BROWSER_VIEW			ENABLE

UINT32         g_uiUIFlowWndPlayCurrenSpeed     = SMEDIAPLAY_SPEED_NORMAL;
UINT32         g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_FORWARD;
BOOL           g_bUIFlowWndPlayNoImgWndOpened   = FALSE;
FST_FILE       gphUIFlowMovPlay_Filehdl         = NULL;
#endif
extern void FlowPB_IconDrawTabNavi(BOOL bShow);

//---------------------UIFlowWndPlayCtrl Function ---------------------------
void UIFlowMoviePlay_SetSpeed(INT16 uiChangeSpeedLevel);

//---------------------UIFlowWndPlayCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndPlay)
CTRL_LIST_ITEM(UIFlowWndPlay_TabNavi)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticICN_DSCMode)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_Flash)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_EV)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticTXT_Size)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_WB)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_Quality)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_Sharpness)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_Storage)
CTRL_LIST_ITEM(UIFlowWndPlay_StatusICN_Battery)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticTXT_Filename)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticICN_Protect)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticTXT_Date)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticTXT_Time)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticTXT_MovPlayTime)
#if defined(_KEY_METHOD_2KEY_)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticTXT_LeftBtn)
CTRL_LIST_ITEM(UIFlowWndPlay_StaticTXT_RightBtn)
#endif
CTRL_LIST_END

//----------------------UIFlowWndPlayCtrl Event---------------------------
INT32 UIFlowWndPlay_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyNext(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeySelect(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyPrev(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyDown(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyRight(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyMenu(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyDisplay(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnBatteryLow(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnKeyPlayback(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnMovieFinish(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnMovieOneSec(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnMovieError(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnStorageInit(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndPlay_OnStorageChange(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPlay)
EVENT_ITEM(NVTEVT_OPEN_WINDOW, UIFlowWndPlay_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW, UIFlowWndPlay_OnClose)
EVENT_ITEM(NVTEVT_KEY_NEXT, UIFlowWndPlay_OnKeyNext)
EVENT_ITEM(NVTEVT_KEY_SELECT, UIFlowWndPlay_OnKeySelect)
EVENT_ITEM(NVTEVT_KEY_PREV, UIFlowWndPlay_OnKeyPrev)
EVENT_ITEM(NVTEVT_KEY_UP, UIFlowWndPlay_OnKeyUp)
EVENT_ITEM(NVTEVT_KEY_DOWN, UIFlowWndPlay_OnKeyDown)
EVENT_ITEM(NVTEVT_KEY_LEFT, UIFlowWndPlay_OnKeyLeft)
EVENT_ITEM(NVTEVT_KEY_RIGHT, UIFlowWndPlay_OnKeyRight)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN, UIFlowWndPlay_OnKeyNext)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT, UIFlowWndPlay_OnKeySelect)
EVENT_ITEM(NVTEVT_KEY_MENU, UIFlowWndPlay_OnKeyMenu)
EVENT_ITEM(NVTEVT_KEY_DISPLAY, UIFlowWndPlay_OnKeyDisplay)
EVENT_ITEM(NVTEVT_KEY_MODE, UIFlowWndPlay_OnKeyMode)
EVENT_ITEM(NVTEVT_CHILD_CLOSE, UIFlowWndPlay_OnChildClose)
EVENT_ITEM(NVTEVT_BATTERY, UIFlowWndPlay_OnBattery)
EVENT_ITEM(NVTEVT_BATTERY_LOW, UIFlowWndPlay_OnBatteryLow)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2, UIFlowWndPlay_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ENTER, UIFlowWndPlay_OnKeyEnter)
EVENT_ITEM(NVTEVT_KEY_PLAYBACK, UIFlowWndPlay_OnKeyPlayback)
EVENT_ITEM(NVTEVT_CB_MOVIE_FINISH, UIFlowWndPlay_OnMovieFinish)
EVENT_ITEM(NVTEVT_CB_MOVIE_ONE_SEC, UIFlowWndPlay_OnMovieOneSec)
EVENT_ITEM(NVTEVT_CB_MOVIE_ERR, UIFlowWndPlay_OnMovieError)
EVENT_ITEM(NVTEVT_STORAGE_INIT, UIFlowWndPlay_OnStorageInit)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE, UIFlowWndPlay_OnStorageChange)
EVENT_END


extern void PBView_DrawErrorView(void);
static void UIFlowWndPlay_CheckStatus(void)
{
	UINT32 uiStatus, uiCurrMode;

	uiStatus = PB_WaitCommandFinish(PB_WAIT_INFINITE);
	PB_GetParam(PBPRMID_PLAYBACK_MODE, &uiCurrMode);

	// Decode Error & Read Error
	if (uiStatus & (PB_STA_ERR_FILE | PB_STA_ERR_DECODE)) {
		if (uiCurrMode == PLAYMODE_AVI || uiCurrMode == PLAYMODE_MOVMJPG) {
			UINT32	uiBuffAddr=0, uiBuffSize=0;
			CHAR	chaFullName[64] = { 0 };

			PB_GetParam(PBPRMID_DATABUF_ADDR, &uiBuffAddr);
			PB_GetParam(PBPRMID_DATABUF_SIZE, &uiBuffSize);
			PB_GetParam(PBPRMID_CURR_FILEPATH, (UINT32 *)&chaFullName);
			SMediaPlay_FileRecovery(chaFullName, uiBuffAddr, uiBuffSize);
			FileDB_Refresh(0);//2016/04/11
			DBG_DUMP("SMediaPlay_FileRecovery is skipped.\r\n");
			uiStatus = UIPlay_PlaySingle(PB_SINGLE_CURR);
			if (uiStatus == PB_STA_DONE) {
				return;
			}
		}
		PBView_DrawErrorView();
		Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, FLOWWRNMSG_ISSUE_PICTURE_ERR, FLOWWRNMSG_TIMER_2SEC);
	}
}

#if PLAY_THUMB_AND_MOVIE // play thumbnail and movie together
INT32 UIFlowWndPlay_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32 uiFileNum = 0;
	PLAY_SINGLE_OBJ FlowPlaySingleObj;
	UINT32  uiStatus = E_OK;

	PB_WaitCommandFinish(PB_WAIT_INFINITE);  // Will this affect the OSD screen? By KS Hung on 20190805.
	//After playback ready, point to the last file
	PB_GetParam(PBPRMID_TOTAL_FILE_COUNT, &uiFileNum);
	//PB_OpenSpecFileBySeq(uiFileNum, TRUE);
	PB_OpenSpecFileBySeq(1, TRUE);
	FlowPlaySingleObj.PlayCommand = PB_SINGLE_CURR;
	FlowPlaySingleObj.PlayCommand |= PB_SINGLE_PRIMARY;
	FlowPlaySingleObj.JumpOffset  = 1;

	//disable video2 and enable video 1
	Display_ShowPreview();

	if (uiStatus & PB_STA_NOIMAGE) {
		Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, FLOWWRNMSG_ISSUE_NO_IMAGE, FLOWWRNMSG_TIMER_2SEC);
		g_bUIFlowWndPlayNoImgWndOpened = TRUE;
	} else {
		Ux_OpenWindow((VControl *)(&UIFlowWndPlayThumbCtrl), 0);
		g_PlbData.VideoPBSpeed = PLB_FWD_MOV_1x;
		g_PlbData.State = PLB_ST_FULL;
		UxTab_SetData(&UIFlowWndPlay_TabNaviCtrl, TAB_FOCUS, UIFlowWndPlay_TabNavi_ButtonPlay);
		UIFlowWndPlay_CheckStatus();
		//FlowPB_UpdateIcons(1);
		FlowPB_UpdateIcons(0);
	}

	// Set mask key
	Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);
	Input_SetKeyMask(KEY_PRESS, PLAY_KEY_PRESS_MASK);
	Input_SetKeyMask(KEY_RELEASE, PLAY_KEY_RELEASE_MASK);
	Input_SetKeyMask(KEY_CONTINUE, PLAY_KEY_CONTINUE_MASK);

	Ux_DefaultEvent(pCtrl, NVTEVT_OPEN_WINDOW, paramNum, paramArray);
	return NVTEVT_CONSUME;
}
#else // normal mode
INT32 UIFlowWndPlay_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32 uiFileNum = 0;
	PLAY_SINGLE_OBJ FlowPlaySingleObj;
	UINT32  uiStatus;

	PB_WaitCommandFinish(PB_WAIT_INFINITE);  // Will this affect the OSD screen? By KS Hung on 20190805.
	//After playback ready, point to the last file
	PB_GetParam(PBPRMID_TOTAL_FILE_COUNT, &uiFileNum);
	PB_OpenSpecFileBySeq(uiFileNum, TRUE);
	FlowPlaySingleObj.PlayCommand = PB_SINGLE_CURR;
	FlowPlaySingleObj.PlayCommand |= PB_SINGLE_PRIMARY;
	FlowPlaySingleObj.JumpOffset  = 1;
	PB_PlaySingleMode(&FlowPlaySingleObj);
	uiStatus = PB_WaitCommandFinish(PB_WAIT_INFINITE);    // Will this affect the OSD screen? By KS Hung on 20190805.

	//disable video2 and enable video 1
	Display_ShowPreview();

	if (uiStatus & PB_STA_NOIMAGE)
		//if(DCF_GetDBInfo(DCF_INFO_TOL_FILE_COUNT)==0)
	{
		Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, FLOWWRNMSG_ISSUE_NO_IMAGE, FLOWWRNMSG_TIMER_2SEC);
		g_bUIFlowWndPlayNoImgWndOpened = TRUE;
	} else {
		g_PlbData.VideoPBSpeed = PLB_FWD_MOV_1x;
		g_PlbData.State = PLB_ST_FULL;
		UxTab_SetData(&UIFlowWndPlay_TabNaviCtrl, TAB_FOCUS, UIFlowWndPlay_TabNavi_ButtonPlay);
		UIFlowWndPlay_CheckStatus();
		FlowPB_UpdateIcons(1);
	}

	// Set mask key
	Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);
	Input_SetKeyMask(KEY_PRESS, PLAY_KEY_PRESS_MASK);
	Input_SetKeyMask(KEY_RELEASE, PLAY_KEY_RELEASE_MASK);
	Input_SetKeyMask(KEY_CONTINUE, PLAY_KEY_CONTINUE_MASK);

	Ux_DefaultEvent(pCtrl, NVTEVT_OPEN_WINDOW, paramNum, paramArray);
	return NVTEVT_CONSUME;
}
#endif

INT32 UIFlowWndPlay_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	switch (g_PlbData.State) {
	case PLB_ST_FULL:
		break;

	case PLB_ST_PLAY_MOV:
	case PLB_ST_PAUSE_MOV:
	case PLB_ST_FWD_MOV:
	case PLB_ST_BWD_MOV:
		// stop movie play
		g_PlbData.State 	   = PLB_ST_FULL;
		g_PlbData.VideoPBSpeed = PLB_FWD_MOV_1x;
		UIFlowMoviePlay_SetSpeed(g_PlbData.VideoPBSpeed);
		g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_FORWARD;
		Ux_SendEvent(0, NVTEVT_EXE_CLOSEPLAY, 0);
		if (gphUIFlowMovPlay_Filehdl) {
			FileSys_CloseFile(gphUIFlowMovPlay_Filehdl);
			gphUIFlowMovPlay_Filehdl = NULL;
		}
		break;
	}

    #if _TODO
	KeyScan_EnableMisc(TRUE);
	#endif

	Ux_DefaultEvent(pCtrl, NVTEVT_CLOSE_WINDOW, paramNum, paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndPlay_OnKeyNext(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	INT32 vdo_idx = -1;

	if (NVTEVT_KEY_RELEASE == paramArray[0]) {
		return NVTEVT_CONSUME;
	}
    DBG_DUMP("%s: g_PlbData.State = %d\r\n", __func__, g_PlbData.State);
	switch (g_PlbData.State) {
	case PLB_ST_FULL:
		Ux_SendEvent(&UIFlowWndPlay_TabNaviCtrl, NVTEVT_NEXT_ITEM, 0);
		break;
	case PLB_ST_PLAY_MOV:
    case PLB_ST_FWD_MOV:
    case PLB_ST_BWD_MOV:
		#if 1//_TODO
        if(g_PlbData.VideoPBSpeed < PLB_FWD_MOV_8x)

        {
            g_PlbData.VideoPBSpeed ++;

            Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
            Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);

            if(g_PlbData.VideoPBSpeed > PLB_FWD_MOV_1x)
            {
                g_PlbData.State = PLB_ST_FWD_MOV;
                g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_FORWARD;
            }
            else if(g_PlbData.VideoPBSpeed < PLB_FWD_MOV_1x)
            {
                if (g_PlbData.VideoPBSpeed == PLB_BWD_MOV_1x) {
                    g_PlbData.VideoPBSpeed = PLB_FWD_MOV_1x;
                    g_PlbData.State = PLB_ST_PLAY_MOV;
                    g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_FORWARD;
                } else {
                    g_PlbData.State = PLB_ST_BWD_MOV;
                    g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_BACKWARD;
                }
            }
            else   //uiCurrSpeedIndex == PLAYMOV_SPEED_FWD_1X
            {
                g_PlbData.State = PLB_ST_PLAY_MOV;
                g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_FORWARD;
            }

			// Set speed and direction
			UIFlowMoviePlay_SetSpeed(g_PlbData.VideoPBSpeed);
			ImageApp_MoviePlay_FilePlay_UpdateSpeedDirect(g_uiUIFlowWndPlayCurrenSpeed, g_uiUIFlowWndPlayCurrenDirection, vdo_idx);

            //FlowPB_IconDrawMovSpeed();
            Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_DEFAULT);
        }
		#endif
        break;
	case PLB_ST_PAUSE_MOV:
        break;
	default:
		break;
	}


	return NVTEVT_CONSUME;
}

INT32 UIFlowWndPlay_OnKeyPrev(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	INT32 vdo_idx = -1;

	if (NVTEVT_KEY_RELEASE == paramArray[0]) {
		return NVTEVT_CONSUME;
	}

	DBG_DUMP("%s: g_PlbData.State = %d\r\n", __func__, g_PlbData.State);
	switch (g_PlbData.State) {
	case PLB_ST_FULL:
		Ux_SendEvent(&UIFlowWndPlay_TabNaviCtrl, NVTEVT_PREVIOUS_ITEM, 0);
		break;
	case PLB_ST_PLAY_MOV:
    case PLB_ST_FWD_MOV:
    case PLB_ST_BWD_MOV:
		#if 1//_TODO
		DBG_DUMP("OnKeyPrev g_PlbData.VideoPBSpeed %x, g_uiUIFlowWndPlayCurrenDirection %d\r\n", g_PlbData.VideoPBSpeed, g_uiUIFlowWndPlayCurrenDirection);
        if(g_PlbData.VideoPBSpeed > PLB_BWD_MOV_8x)
        {
            if (g_PlbData.VideoPBSpeed == PLB_FWD_MOV_1x) {
                g_PlbData.VideoPBSpeed -= 2;
            } else {
                g_PlbData.VideoPBSpeed--;
            }

            Ux_FlushEventByRange(NVTEVT_KEY_EVT_START,NVTEVT_KEY_EVT_END);
            Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);

            if(g_PlbData.VideoPBSpeed > PLB_FWD_MOV_1x)
            {
                g_PlbData.State = PLB_ST_FWD_MOV;
				g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_FORWARD;
            }
            else if(g_PlbData.VideoPBSpeed < PLB_FWD_MOV_1x)
            {
                g_PlbData.State = PLB_ST_BWD_MOV;
				g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_BACKWARD;
            }
            else   //uiCurrSpeedIndex == PLAYMOV_SPEED_FWD_1X
            {
                g_PlbData.State = PLB_ST_PLAY_MOV;
                g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_FORWARD;
            }

			UIFlowMoviePlay_SetSpeed(g_PlbData.VideoPBSpeed);
			ImageApp_MoviePlay_FilePlay_UpdateSpeedDirect(g_uiUIFlowWndPlayCurrenSpeed, g_uiUIFlowWndPlayCurrenDirection, vdo_idx);

            Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_DEFAULT);
        }
		#endif
        break;
	case PLB_ST_PAUSE_MOV:
        break;
	default:
		break;
	}

	return NVTEVT_CONSUME;
}

INT32 UIFlowWndPlay_OnKeySelect(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    UINT32 Tabfocus;
    #if 1//_TODO
	char   pFilePath[FULL_FILE_PATH_LEN] = {0};
	UINT32 uiPBFileFmt = PBFMT_MP4;
	UINT32 uiPBFileSize = 0;
	#endif

	if (NVTEVT_KEY_RELEASE == paramArray[0]) {
		return NVTEVT_CONSUME;
	}
	switch (g_PlbData.State) {
	case PLB_ST_FULL:
		Tabfocus = UxTab_GetData(&UIFlowWndPlay_TabNaviCtrl, TAB_FOCUS);
		switch (Tabfocus) {
		case UIFlowWndPlay_TabNavi_ButtonPlay:
			#if 1//_TODO
			PB_GetParam(PBPRMID_CURR_FILEFMT, &uiPBFileFmt);
			if (uiPBFileFmt & (PBFMT_MOVMJPG | PBFMT_AVI | PBFMT_MP4 | PBFMT_TS)) {
				UINT32 u32CurrPbStatus = 0;

			    PB_GetParam(PBPRMID_PLAYBACK_STATUS, &u32CurrPbStatus);
				if (u32CurrPbStatus != PB_STA_DONE){
					return NVTEVT_CONSUME;
				}

				// Open Video File
				if (gphUIFlowMovPlay_Filehdl) {
					FileSys_CloseFile(gphUIFlowMovPlay_Filehdl);
					gphUIFlowMovPlay_Filehdl = NULL;
				}
				if (uiPBFileFmt & PBFMT_TS) {
					PB_GetParam(PBPRMID_CURR_FILESIZE, &uiPBFileSize);
					if (uiPBFileSize <= 0x10000) {
						DBG_DUMP("Wrong video file format!! \r\n");
						break;
					}
				}
				// Get Current index
				PB_GetParam(PBPRMID_CURR_FILEPATH, (UINT32 *)pFilePath);

				// Open Test Media File
				gphUIFlowMovPlay_Filehdl = FileSys_OpenFile(pFilePath, FST_OPEN_READ);

				if (!gphUIFlowMovPlay_Filehdl) {
					DBG_DUMP("UIFlowWndPlay_OnKeySelect: Can't open Video file!\r\n");
					break;
				}
#if 0
				KeyScan_EnableMisc(FALSE);
				UIFlowMoviePlay_SetSpeed(g_PlbData.VideoPBSpeed);
				g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_FORWARD;
#endif

				FlowPB_UpdateIcons(0); /* FlowPB_IconDrawImageSize needs exif buffer, should be invoked before NVTEVT_EXE_CLOSE */

				Ux_SendEvent(0, NVTEVT_EXE_CLOSE, 0); //CustomPlayObjCmdMap

				//flush event first
				Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);

				//stop scan
#if 0
				//SxTimer_SetFuncActive(SX_TIMER_DET_STRG_ID, FALSE);
				SxTimer_SetFuncActive(SX_TIMER_DET_SYSTEM_BUSY_ID, FALSE);
#endif

#if 0
				ImageApp_MoviePlay_Open();
				ImageApp_MoviePlay_Start();
#else			// Wake up CustomMoviePlayObjCtrl obj.
				Ux_SetActiveApp(&CustomMoviePlayObjCtrl);
				Ux_SendEvent(0, NVTEVT_EXE_OPENPLAY, 1, (UINT32)gphUIFlowMovPlay_Filehdl);
				Ux_SendEvent(0, NVTEVT_EXE_STARTPLAY, 0);
#endif

				//set movie volumn
				Ux_SendEvent(&CustomMoviePlayObjCtrl, NVTEVT_EXE_MOVIEAUDPLAYVOLUME, 2, UI_GetData(FL_MovieAudioPlayIndex), 1);

				g_PlbData.State = PLB_ST_PLAY_MOV;
				FlowPB_IconDrawLeftBtn(TRUE);
				FlowPB_IconDrawRightBtn(TRUE);
				FlowPB_IconDrawMovPlayTime(TRUE);
			} else {
				g_PlbData.State = PLB_ST_MAGNIFY;
				FlowPB_UpdateIcons(0);
				FlowPB_IconDrawLeftBtn(TRUE);

				//#NT#2017/11/17#Adam Su -begin
				//#NT#AUTO_TEST
				PB_GetParam(PBPRMID_CURR_FILEPATH, (UINT32 *)pFilePath);
				exam_msg("Play File Path = %s\r\n", pFilePath);
				//#NT#2017/11/17#Adam Su -end
			}
			#endif
			break;
		case UIFlowWndPlay_TabNavi_ButtonLeft:
			Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
			UIPlay_PlaySingle(PB_SINGLE_PREV);
			UIFlowWndPlay_CheckStatus();
			FlowPB_UpdateIcons(1);
			Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_DEFAULT);
			break;
		case UIFlowWndPlay_TabNavi_ButtonRight:
			Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
			UIPlay_PlaySingle(PB_SINGLE_NEXT);
			UIFlowWndPlay_CheckStatus();
			FlowPB_UpdateIcons(1);
			Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_DEFAULT);
			break;
		case UIFlowWndPlay_TabNavi_ButtonUp:
			Ux_OpenWindow(&MenuCommonConfirmCtrl, 1, IDM_DELETE_THIS);
			break;
		case UIFlowWndPlay_TabNavi_ButtonDown:
			g_PlbData.State = PLB_ST_MENU;
			// Reset specific menu items
			SysSetFlag(FL_PROTECT, PROTECT_ONE);
			// Set Tab menu to Playback menu
			// Open common item menu
			Ux_OpenWindow(&MenuCommonItemCtrl, 0);
			Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_DEFAULT);
			break;
		default:
			break;
		}
		break;
	case PLB_ST_MAGNIFY:
		g_PlbData.State = PLB_ST_FULL;
		FlowPB_UpdateIcons(1);
		break;
	case PLB_ST_PLAY_MOV:
	case PLB_ST_PAUSE_MOV:
		#if 1//_TODO
		g_PlbData.State 	   = PLB_ST_FULL;
		g_PlbData.VideoPBSpeed = PLB_FWD_MOV_1x;
#if 0
		UIFlowMoviePlay_SetSpeed(g_PlbData.VideoPBSpeed);
		g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_FORWARD;
#endif

		#if 0
		ImageApp_MoviePlay_Close();
		#else // Close MoviePlay module.
		Ux_SendEvent(0, NVTEVT_EXE_CLOSEPLAY, 0);
		Ux_SetActiveApp(&CustomPlayObjCtrl);
		#endif

#if 0
		if (gMovie_Play_Info.event_cb) {
			gMovie_Play_Info.event_cb(MOVIEPLAY_EVENT_STOP);
		}
		if (UIStorageCheck(STORAGE_CHECK_ERROR, NULL) == TRUE) {
			return NVTEVT_CONSUME;
		}
#endif

		#if 0
		ImageApp_Play_Open();
		#else // Wakeup playback task and ImageApp_Play module.
		Ux_SendEvent(0, NVTEVT_EXE_OPEN, 0);
		#endif
#if 0
		KeyScan_EnableMisc(TRUE);

		if (SxTimer_GetFuncActive(SX_TIMER_DET_SYSTEM_BUSY_ID) == 0) {
			SxTimer_SetFuncActive(SX_TIMER_DET_SYSTEM_BUSY_ID, TRUE);
		}
#endif

		if (gphUIFlowMovPlay_Filehdl) {
			FileSys_CloseFile(gphUIFlowMovPlay_Filehdl);
			gphUIFlowMovPlay_Filehdl = NULL;
		}

		// Play 1st video frame image
		UIPlay_PlaySingle(PB_SINGLE_CURR);
		FlowPB_UpdateIcons(1);
        #endif
		break;
	case PLB_ST_FWD_MOV:
	case PLB_ST_BWD_MOV:
		#if _TODO
		KeyScan_EnableMisc(FALSE);

		// Set to Normal Play
		g_PlbData.VideoPBSpeed = PLB_FWD_MOV_1x;
		UIFlowMoviePlay_SetSpeed(g_PlbData.VideoPBSpeed);
		g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_FORWARD;

		// Start Play
		vdo_idx = AppDisp_MoviePlayView_GetDispIdx(); // get current display video index
		ImageApp_MoviePlay_FilePlay_UpdateSpeedDirect(g_uiUIFlowWndPlayCurrenSpeed, g_uiUIFlowWndPlayCurrenDirection, vdo_idx);
		g_PlbData.State = PLB_ST_PLAY_MOV;
		#endif
		break;
	}

	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyDisplay(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32 uiStatus;

	//#NT#2012/12/27#Hideo Lin -begin
	//#NT#Fix close child window hang up as card removed
	if (Ux_IsForceCloseWindow()) {
		return NVTEVT_CONSUME;
	}
	//#NT#2012/12/27#Hideo Lin -end

	if (paramNum > 0) {
		//Return from thumbnail, magnify or delete mode and play current image again.
		switch (paramArray[0]) {
		case NVTRET_THUMBNAIL:
		case NVTRET_MAGNIFY:
			UIPlay_PlaySingle(PB_SINGLE_CURR);
			UIFlowWndPlay_CheckStatus();
			FlowPB_UpdateIcons(1);
			break;
		case NVTRET_DELETE:
		case NVTRET_DELETEALL:
			uiStatus = PB_WaitCommandFinish(PB_WAIT_INFINITE);

			if (uiStatus & PB_STA_NOIMAGE)
				//if(DCF_GetDBInfo(DCF_INFO_TOL_FILE_COUNT)==0)
			{
				if (!g_bUIFlowWndPlayNoImgWndOpened) {
					Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, FLOWWRNMSG_ISSUE_NO_IMAGE, FLOWWRNMSG_TIMER_2SEC);
					g_bUIFlowWndPlayNoImgWndOpened = TRUE;
				}
			} else {
				UIPlay_PlaySingle(PB_SINGLE_CURR);
				UIFlowWndPlay_CheckStatus();
				FlowPB_UpdateIcons(1);
			}
			break;
		case NVTRET_ENTER_MENU:
			// Reset specific menu items
			SysSetFlag(FL_PROTECT, PROTECT_ONE);
			// Open common item menu
			Ux_OpenWindow(&MenuCommonItemCtrl, 0);
			g_bUIFlowWndPlayNoImgWndOpened = FALSE;
			break;
		case NVTRET_WARNING:
			Ux_PostEvent(paramArray[1], 0);
			break;
		}
	} else {
		UIPlay_PlaySingle(PB_SINGLE_CURR);
		uiStatus = PB_WaitCommandFinish(PB_WAIT_INFINITE);
		if (uiStatus & PB_STA_NOIMAGE)
			//if(DCF_GetDBInfo(DCF_INFO_TOL_FILE_COUNT)==0)
		{
			if (!g_bUIFlowWndPlayNoImgWndOpened) {
				Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, FLOWWRNMSG_ISSUE_NO_IMAGE, FLOWWRNMSG_TIMER_2SEC);
				g_bUIFlowWndPlayNoImgWndOpened = TRUE;
			} else {
				g_PlbData.State = PLB_ST_MENU;
				Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
				// Reset specific menu items
				SysSetFlag(FL_PROTECT, PROTECT_ONE);
				// Open common item menu
				Ux_OpenWindow(&MenuCommonItemCtrl, 0);
				Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_DEFAULT);
			}
		} else { //file error
			FlowPB_UpdateIcons(1);
		}
	}
	g_PlbData.State = PLB_ST_FULL;

    #if _TODO
	KeyScan_EnableMisc(TRUE);
	#endif

	// set mask key
	Input_SetKeyMask(KEY_PRESS, PLAY_KEY_PRESS_MASK);
	Input_SetKeyMask(KEY_RELEASE, PLAY_KEY_RELEASE_MASK);
	Input_SetKeyMask(KEY_CONTINUE, PLAY_KEY_CONTINUE_MASK);
	Ux_DefaultEvent(pCtrl, NVTEVT_CHILD_CLOSE, paramNum, paramArray);

	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if _TODO
	static volatile BOOL bBatteryOn = FALSE;

	UxState_SetData(&UIFlowWndPlay_StatusICN_BatteryCtrl, STATE_CURITEM, GetBatteryLevel());
	if (KeyScan_IsACIn()) {
		bBatteryOn = !bBatteryOn;
		UxCtrl_SetShow(&UIFlowWndPlay_StatusICN_BatteryCtrl, bBatteryOn);
	} else {
		UxCtrl_SetShow(&UIFlowWndPlay_StatusICN_BatteryCtrl, TRUE);
	}
#endif
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnBatteryLow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_BATTERY_LOW, FLOWWRNMSG_TIMER_2SEC);
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	if (NVTEVT_KEY_RELEASE == paramArray[0]) {
		return NVTEVT_CONSUME;
	}

	switch (g_PlbData.State) {
	case PLB_ST_PLAY_MOV:
        #if 1//_TODO
		Ux_SendEvent(0, NVTEVT_EXE_PAUSEPLAY, 0);
		g_PlbData.State = PLB_ST_PAUSE_MOV;
		//FlowPB_IconDrawRightBtn(TRUE);

		//KeyScan_EnableMisc(TRUE);
		#endif
		break;
	case PLB_ST_PAUSE_MOV:
        #if 1//_TODO
        //KeyScan_EnableMisc(TRUE);

		// Start to Play
		//set movie volumn again to avoid volumn changed by beep sound
		Ux_SendEvent(&CustomMoviePlayObjCtrl, NVTEVT_EXE_MOVIEAUDPLAYVOLUME, 2, UI_GetData(FL_MovieAudioPlayIndex), 1);
		Ux_SendEvent(0, NVTEVT_EXE_RESUMEPLAY, 0);
		g_PlbData.State = PLB_ST_PLAY_MOV;
		//FlowPB_IconDrawRightBtn(TRUE);
		#endif
		break;
#if (BROWSER_VIEW == ENABLE)
	case PLB_ST_FULL:
		Ux_OpenWindow((VControl *)(&UIFlowWndPlayThumbCtrl), 0);
		break;
#endif
	default:
		break;
	}

	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyEnter(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnKeyPlayback(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnMovieFinish(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    switch (g_PlbData.State) {
    case PLB_ST_FULL:
        break;

    case PLB_ST_PLAY_MOV:
    case PLB_ST_PAUSE_MOV:
    case PLB_ST_FWD_MOV:
    case PLB_ST_BWD_MOV:
#if 1//_TODO
    	g_PlbData.State 	   = PLB_ST_FULL;
    	g_PlbData.VideoPBSpeed = PLB_FWD_MOV_1x;

#if 0
    	UIFlowMoviePlay_SetSpeed(g_PlbData.VideoPBSpeed);
    	g_uiUIFlowWndPlayCurrenDirection = SMEDIAPLAY_DIR_FORWARD;
#endif


    	Ux_SendEvent(0, NVTEVT_EXE_CLOSEPLAY, 0);
    	Ux_SetActiveApp(&CustomPlayObjCtrl);

    	#if 0
    	ImageApp_Play_Open();
    	#else // Wakeup playback task and ImageApp_Play module.
    	Ux_SendEvent(0, NVTEVT_EXE_OPEN, 0);
    	#endif

    	#if 0
    	KeyScan_EnableMisc(TRUE);

    	if (SxTimer_GetFuncActive(SX_TIMER_DET_SYSTEM_BUSY_ID) == 0) {
    		SxTimer_SetFuncActive(SX_TIMER_DET_SYSTEM_BUSY_ID, TRUE);
    	}
    	#endif

    	if (gphUIFlowMovPlay_Filehdl) {
    		FileSys_CloseFile(gphUIFlowMovPlay_Filehdl);
    		gphUIFlowMovPlay_Filehdl = NULL;
    	}

    	// Play 1st video frame image
    	UIPlay_PlaySingle(PB_SINGLE_CURR);

    	FlowPB_UpdateIcons(1);

    	#if FLOW_MOV_PLAY_REAET // Repeat play test only. To be removed.
    	vos_util_delay_ms(1000);
    	Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
    	#endif

    	//#NT#2016/11/10#Niven Cho -begin
    	//#NT#AUTO_TEST
    	//exam_msg("OnMovieFinish\r\n");
    	//#NT#2016/11/10#Niven Cho -end
#endif
        break;

    default:
        break;
    }

	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnMovieOneSec(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    FlowPB_IconDrawMovPlayTime(TRUE);
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnMovieError(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, FLOWWRNMSG_ISSUE_PICTURE_ERR, FLOWWRNMSG_TIMER_2SEC);
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnStorageInit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndPlay_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (SDHOTPLUG_FUNCTION == ENABLE)
		Ux_PostEvent(NVTEVT_SYSTEM_MODE, 1, System_GetState(SYS_STATE_CURRMODE));
#endif

	return NVTEVT_CONSUME;
}

void UIFlowMoviePlay_SetSpeed(INT16 uiChangeSpeedLevel)
{
#if 1//_TODO
	switch (uiChangeSpeedLevel) {
	default:
	case PLB_FWD_MOV_1x:
	case PLB_BWD_MOV_1x:
		g_uiUIFlowWndPlayCurrenSpeed = SMEDIAPLAY_SPEED_NORMAL;
		break;

	case PLB_FWD_MOV_2x:
	case PLB_BWD_MOV_2x:
		g_uiUIFlowWndPlayCurrenSpeed = SMEDIAPLAY_SPEED_2X;
		break;

	case PLB_FWD_MOV_4x:
	case PLB_BWD_MOV_4x:
		g_uiUIFlowWndPlayCurrenSpeed = SMEDIAPLAY_SPEED_4X;
		break;

	case PLB_FWD_MOV_8x:
	case PLB_BWD_MOV_8x:
		g_uiUIFlowWndPlayCurrenSpeed = SMEDIAPLAY_SPEED_8X;
		break;

	}
#endif
}

//----------------------UIFlowWndPlay_TabNaviCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_TabNavi)
EVENT_END

//----------------------ButtonPlayCtrl Event---------------------------
EVENT_BEGIN(ButtonPlay)
EVENT_END

//----------------------ButtonLeftCtrl Event---------------------------
EVENT_BEGIN(ButtonLeft)
EVENT_END

//----------------------ButtonRightCtrl Event---------------------------
EVENT_BEGIN(ButtonRight)
EVENT_END

//----------------------ButtonUpCtrl Event---------------------------
EVENT_BEGIN(ButtonUp)
EVENT_END

//----------------------ButtonDownCtrl Event---------------------------
EVENT_BEGIN(ButtonDown)
EVENT_END

//----------------------UIFlowWndPlay_StaticICN_DSCModeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticICN_DSCMode)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_FlashCtrl Event---------------------------
INT32 UIFlowWndPlay_StatusICN_Flash_OnKeyRight(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndPlay_StatusICN_Flash)
EVENT_ITEM(NVTEVT_KEY_RIGHT, UIFlowWndPlay_StatusICN_Flash_OnKeyRight)
EVENT_END

INT32 UIFlowWndPlay_StatusICN_Flash_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	Ux_SendEvent(pCtrl, NVTEVT_NEXT_ITEM, 0);
	return NVTEVT_CONSUME;
}
//----------------------UIFlowWndPlay_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndPlay_StaticTXT_SizeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticTXT_Size)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_WBCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_WB)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_QualityCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_Quality)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_SharpnessCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_Sharpness)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_Storage)
EVENT_END

//----------------------UIFlowWndPlay_StatusICN_BatteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StatusICN_Battery)
EVENT_END

//----------------------UIFlowWndPlay_StaticTXT_FilenameCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticTXT_Filename)
EVENT_END

//----------------------UIFlowWndPlay_StaticICN_ProtectCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticICN_Protect)
EVENT_END

//----------------------UIFlowWndPlay_StaticTXT_DateCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticTXT_Date)
EVENT_END

//----------------------UIFlowWndPlay_StaticTXT_TimeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticTXT_Time)
EVENT_END

//----------------------UIFlowWndPlay_StaticTXT_MovPlayTimeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticTXT_MovPlayTime)
EVENT_END

//----------------------UIFlowWndPlay_StaticTXT_LeftBtnCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticTXT_LeftBtn)
EVENT_END

//----------------------UIFlowWndPlay_StaticTXT_RightBtnCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndPlay_StaticTXT_RightBtn)
EVENT_END

