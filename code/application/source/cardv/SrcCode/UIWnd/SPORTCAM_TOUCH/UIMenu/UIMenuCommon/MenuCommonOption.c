//This source code is generated by UI Designer Studio.

#include "PrjInc.h"
#include "UIWnd/UIFlow.h"
#include "MenuCommonOptionRes.c"
#include "MenuCommonOption.h"

//#NT#2016/09/20#Bob Huang -begin
//#NT#Support HDMI Display with 3DNR Out
#if (_3DNROUT_FUNC == ENABLE)
extern BOOL gb3DNROut;
#endif
//#NT#2016/09/20#Bob Huang -end

//---------------------MenuCommonOptionCtrl Debug Definition -----------------------------
#define __MODULE__          MenuCommonOption
#define __DBGLVL__          2 // 0=FATAL, 1=ERR, 2=WRN, 3=UNIT, 4=FUNC, 5=IND, 6=MSG, 7=VALUE, 8=USER
#define __DBGFLT__          "*" //*=All, [mark]=CustomClass
#include <kwrap/debug.h>

#define _MENUCOMMONOPTION_ERROR_MSG        0
#define _MENUCOMMONOPTION_TRACE_MSG        0

#if (_MENUCOMMONOPTION_ERROR_MSG&(PRJ_DBG_LVL>=PRJ_DBG_LVL_ERR))
#define MenuCommonOptionErrMsg(...)            debug_msg ("^R MenuCommonOption: "__VA_ARGS__)
#else
#define MenuCommonOptionErrMsg(...)
#endif

#if (_MENUCOMMONOPTION_TRACE_MSG&(PRJ_DBG_LVL>=PRJ_DBG_LVL_TRC))
#define MenuCommonOptionTraceMsg(...)          debug_msg ("^B MenuCommonOption: "__VA_ARGS__)
#else
#define MenuCommonOptionTraceMsg(...)
#endif

//---------------------MenuCommonOptionCtrl Global Variables -----------------------------
#define PAGE           4
#if 1//defined(YQCONFIG_TOUCH_FUNCTION_SUPPORT)
#define PRE_DUMMY_ITEM        2
#define MAX_SUPPROTED_ITEM   18
//#define (Menu_rect.y2-Menu_rect.y1)   30

static INT32    g_TouchPressX;
static INT32    g_TouchPressY;
static INT32    g_PressedItem;
static INT32    g_MenuMoved;
static Ux_RECT  Menu_rect;
static INT32    EnabledItem;
static INT32    ItemReMap[PRE_DUMMY_ITEM + MAX_SUPPROTED_ITEM];
#endif
//---------------------MenuCommonOptionCtrl Prototype Declaration  -----------------------

//---------------------MenuCommonOptionCtrl Public API  ----------------------------------

//---------------------MenuCommonOptionCtrl Private API  ---------------------------------
static TM_MENU *g_pOptionMenu = 0;

static void MenuCommonOption_SetCurrentMenu(TM_MENU *pMenu)
{
	g_pOptionMenu = pMenu;
}

static TM_MENU *MenuCommonOption_GetCurrentMenu(void)
{
	return g_pOptionMenu;
}

static void MenuCommonOption_UpdateContent(TM_MENU *pMenu)
{
	TM_PAGE    *pPage;
	TM_ITEM    *pItem;
	TM_OPTION  *pOption;
	UINT32      i;
	UINT16      startIndex = 0;
	UINT16      itemIndex = 0;
	UINT16      SelOption = 0;
	pPage = &pMenu->pPages[pMenu->SelPage];
	pItem = &pPage->pItems[pPage->SelItem];
	SelOption = SysGetFlag(pItem->SysFlag);
	TM_CheckOptionStatus(pMenu, &SelOption, TRUE);
	SysSetFlag(pItem->SysFlag, SelOption); //SelOption might change

	pOption = &pItem->pOptions[SelOption];

	if (pItem->Count) {
		UxCtrl_SetShow(&MenuCommonOption_StatusCtrl, TRUE);
		if (pOption->TextId & STRID_USER_START) {
			UxMenu_SetItemData(&MenuCommonOption_StatusCtrl, 0, MNUITM_STRID,  Txt_Pointer(UIRes_GetUserString(pOption->TextId)));
		} else {
			UxMenu_SetItemData(&MenuCommonOption_StatusCtrl, 0, MNUITM_STRID,  pOption->TextId);
		}
	} else {
		if (pItem->ItemId == IDM_VERSION) {
			UxCtrl_SetShow(&MenuCommonOption_StatusCtrl, TRUE);
			UxMenu_SetItemData(&MenuCommonOption_StatusCtrl, 0, MNUITM_STRID,  Txt_Pointer(Prj_GetVersionString()));
		} else {
			UxCtrl_SetShow(&MenuCommonOption_StatusCtrl, FALSE);
		}
	}

	if (pItem->TextId & STRID_USER_START) {
		UxMenu_SetItemData(&MenuCommonOption_TitleCtrl, 0, MNUITM_STRID,  Txt_Pointer(UIRes_GetUserString(pItem->TextId)));
	} else {
		UxMenu_SetItemData(&MenuCommonOption_TitleCtrl, 0, MNUITM_STRID,  pItem->TextId);
	}


	//find startIndex
	TM_FindStartIndex(pMenu, PAGE, &startIndex);

	//draw item form startIndex
	itemIndex = startIndex;
	for (i = 0; i < PAGE; i++) {
		//check item if disable
		TM_CheckItemStatus(pMenu, &itemIndex, TRUE);
		if ((itemIndex == pPage->Count) && (i < PAGE)) {
			UxList_SetItemData(&MenuCommonOption_ListCtrl, i, LSTITM_STATUS, STATUS_DISABLE);
		} else {
			pItem = &pPage->pItems[itemIndex];
			UxList_SetItemData(&MenuCommonOption_ListCtrl, i, LSTITM_STATUS, STATUS_ENABLE);
			UxList_SetItemData(&MenuCommonOption_ListCtrl, i, LSTITM_STRID,  pItem->TextId);
			UxList_SetItemData(&MenuCommonOption_ListCtrl, i, LSTITM_ICONID, pItem->IconId);
			itemIndex++;
		}
	}
}
static void MenuCommonOption_UpdatePosition(void)
{
	ISIZE str_size;
	Ux_RECT MenuRect, NewRect;
	UINT32 strId = UxMenu_GetItemData(&MenuCommonOption_TitleCtrl, CURITEM_INDEX, MNUITM_STRID);

	//avoid other tmp UI change font table
	GxGfx_SetTextStroke((const FONT *)gDemoKit_Font, FONTSTYLE_NORMAL, SCALE_1X);

	if (strId & TEXT_POINTER) {
		strId = (strId) & ~TEXT_POINTER;
		GxGfx_TextPrint(0, 0, 0, "%s", strId);
	} else {
		GxGfx_Text(0, 0, 0, GxGfx_GetStringID(strId));
	}

	str_size = GxGfx_GetTextLastSize();
	UxCtrl_GetPos(&MenuCommonOption_TitleCtrl, &MenuRect);
	UxCtrl_GetPos(&MenuCommonOption_StatusCtrl, &NewRect);
	NewRect.x1 = MenuRect.x1 + str_size.w + 5   ;
	UxCtrl_SetPos(&MenuCommonOption_StatusCtrl, NewRect);
}

//---------------------MenuCommonOptionCtrl Control List---------------------------
CTRL_LIST_BEGIN(MenuCommonOption)
CTRL_LIST_ITEM(MenuCommonOption_List)
CTRL_LIST_ITEM(MenuCommonOption_Title)
CTRL_LIST_ITEM(MenuCommonOption_Status)
CTRL_LIST_ITEM(MenuCommOption_Panel)
CTRL_LIST_ITEM(MenuCommonOption_STA_Title)
CTRL_LIST_ITEM(MenuCommonOption_PNL)
CTRL_LIST_ITEM(MenuCommonOption_MNU_Selection)
CTRL_LIST_ITEM(MenuCommonOption_BTN_OK)
CTRL_LIST_ITEM(MenuCommonOption_BTN_Cancel)
CTRL_LIST_END

//----------------------MenuCommonOptionCtrl Event---------------------------
INT32 MenuCommonOption_OnOpen(VControl *, UINT32, UINT32 *);
INT32 MenuCommonOption_OnClose(VControl *, UINT32, UINT32 *);
INT32 MenuCommonOption_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 MenuCommonOption_OnStorageChange(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(MenuCommonOption)
EVENT_ITEM(NVTEVT_OPEN_WINDOW, MenuCommonOption_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW, MenuCommonOption_OnClose)
EVENT_ITEM(NVTEVT_CHILD_CLOSE, MenuCommonOption_OnChildClose)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE, MenuCommonOption_OnStorageChange)
EVENT_END

INT32 MenuCommonOption_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	TM_MENU    *pMenu;
	TM_PAGE    *pPage;
	TM_ITEM    *pItem;
	TM_OPTION  *pOption;
	UINT16      SelOption = 0;
    INT32       i;

	if (paramNum == 1) {
        #if 1//defined(YQCONFIG_TOUCH_FUNCTION_SUPPORT)
        // Get and store menu positon for move calculation.
        UxCtrl_GetPos((VControl *)&MenuCommonOption_MNU_SelectionCtrl,&Menu_rect);

        // Initial variables
        g_MenuMoved = FALSE;

        // Get current page/item/option
        MenuCommonOption_SetCurrentMenu((TM_MENU*)paramArray[0]);
        pMenu = MenuCommonOption_GetCurrentMenu();
        pPage = &pMenu->pPages[pMenu->SelPage];
        pItem = &pPage->pItems[pPage->SelItem];
        SelOption = SysGetFlag(pItem->SysFlag);

        // Update title
        UxStatic_SetData(&MenuCommonOption_STA_TitleCtrl, STATIC_VALUE, pItem->TextId);

        // Set total item number to max
        UxMenu_SetData(&MenuCommonOption_MNU_SelectionCtrl, MNU_TOTITM, (PRE_DUMMY_ITEM + MAX_SUPPROTED_ITEM));

        // Insert first two dummy options.
        for (EnabledItem = 0; EnabledItem < PRE_DUMMY_ITEM; EnabledItem ++) {
            UxMenu_SetItemData(&MenuCommonOption_MNU_SelectionCtrl, EnabledItem, MNUITM_STRID,  STRID_NULL_);
        }

        // Set 1st valid item to default current item in case selOption is invalid.
        UxMenu_SetData(&MenuCommonOption_MNU_SelectionCtrl, MNU_CURITM, EnabledItem);

        if (pItem->ItemId == IDM_VERSION) {
            UxMenu_SetItemData(&MenuCommonOption_MNU_SelectionCtrl, EnabledItem, MNUITM_STRID,  Txt_Pointer(Prj_GetVersionString()));
            EnabledItem ++;
        }  else {
            // Add enabled options to menu
            for (i = 0; i < pItem->Count; i ++) {
                pOption = &pItem->pOptions[i];

                if ((pOption->Status & TM_OPTION_STATUS_MASK) == TM_OPTION_ENABLE) {
                    // Save option to ItemReMap[]
                    ItemReMap[EnabledItem] = i;

                    // Update string
                    if(pOption->TextId & STRID_USER_START) {
                        UxMenu_SetItemData(&MenuCommonOption_MNU_SelectionCtrl, EnabledItem, MNUITM_STRID,  Txt_Pointer(UIRes_GetUserString(pOption->TextId)));
                    } else {
                        UxMenu_SetItemData(&MenuCommonOption_MNU_SelectionCtrl, EnabledItem, MNUITM_STRID,  pOption->TextId);
                    }

                    // Update current item if match
                    if (i == SelOption) {
                        UxMenu_SetData(&MenuCommonOption_MNU_SelectionCtrl, MNU_CURITM, EnabledItem);      // Set current item to correct one
                    }

                    EnabledItem ++;

                    // If exceed max support options, break and send warning message
                    if (EnabledItem >= (PRE_DUMMY_ITEM + MAX_SUPPROTED_ITEM)) {
                        DBG_ERR("Exceed max supported options!");
                        break;
                    }
                }
            }
        }
        // Update correct total item number
        UxMenu_SetData(&MenuCommonOption_MNU_SelectionCtrl, MNU_TOTITM, EnabledItem);

        #else
        MenuCommonOption_SetCurrentMenu((TM_MENU*)paramArray[0]);
        pMenu = MenuCommonOption_GetCurrentMenu();
		pMenu->Status = TMS_ON_OPTION;
		pMenu->SelPage = 0;

		pPage = &pMenu->pPages[pMenu->SelPage];
		pPage->SelItem = 0;
		//check item if disable
		TM_CheckItemStatus(pMenu, &pPage->SelItem, TRUE);
		pItem = &pPage->pItems[pPage->SelItem];
		if (pItem->Count > 0) {
			SelOption = SysGetFlag(pItem->SysFlag);
			//check option if disable
			TM_CheckOptionStatus(pMenu, &SelOption, TRUE);
			SysSetFlag(pItem->SysFlag, SelOption); //SelOption might change

			pOption = &pItem->pOptions[SelOption];

			UxMenu_SetItemData(&MenuCommonOption_StatusCtrl, 0, MNUITM_STRID,  pOption->TextId);
		}

		UxList_SetData(&MenuCommonOption_ListCtrl, LST_CURITM, 0);
		MenuCommonOption_UpdateContent(pMenu);
		MenuCommonOption_UpdatePosition();
        #if _TODO
		UI_SetDisplayPalette(LAYER_OSD1, 0, 256, gDemoKit_PaletteOption_Palette);
        #endif
		#endif
		
	}
	
	Ux_DefaultEvent(pCtrl, NVTEVT_OPEN_WINDOW, paramNum, paramArray);
	return NVTEVT_CONSUME;
}
INT32 MenuCommonOption_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    #if _TODO
	UI_SetDisplayPalette(LAYER_OSD1, 0, 256, gDemoKit_Palette_Palette);
    #endif
	Ux_DefaultEvent(pCtrl, NVTEVT_CLOSE_WINDOW, paramNum, paramArray);
	return NVTEVT_CONSUME;
}
INT32 MenuCommonOption_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    #if 0//!defined(YQCONFIG_TOUCH_FUNCTION_SUPPORT)
	TM_MENU    *pMenu = MenuCommonOption_GetCurrentMenu();
	pMenu->Status = TMS_ON_OPTION;
	MenuCommonOption_UpdateContent(pMenu);
	MenuCommonOption_UpdatePosition();
    #endif
	Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_DEFAULT);
	Ux_DefaultEvent(pCtrl, NVTEVT_CHILD_CLOSE, paramNum, paramArray);
	return NVTEVT_CONSUME;
}
INT32 MenuCommonOption_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (SDHOTPLUG_FUNCTION == ENABLE)
	Ux_PostEvent(NVTEVT_SYSTEM_MODE, 1, System_GetState(SYS_STATE_CURRMODE));
#endif
	return NVTEVT_CONSUME;
}
//----------------------MenuCommonOption_ListCtrl Event---------------------------
INT32 MenuCommonOption_List_OnKeyNext(VControl *, UINT32, UINT32 *);
INT32 MenuCommonOption_List_OnKeyPrev(VControl *, UINT32, UINT32 *);
INT32 MenuCommonOption_List_OnKeySelect(VControl *, UINT32, UINT32 *);
INT32 MenuCommonOption_List_OnKeyExit(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(MenuCommonOption_List)
EVENT_ITEM(NVTEVT_KEY_NEXT, MenuCommonOption_List_OnKeyNext)
EVENT_ITEM(NVTEVT_KEY_PREV, MenuCommonOption_List_OnKeyPrev)
EVENT_ITEM(NVTEVT_KEY_SELECT, MenuCommonOption_List_OnKeySelect)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2, MenuCommonOption_List_OnKeyExit)

EVENT_END

INT32 MenuCommonOption_List_OnKeyNext(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	TM_MENU    *pMenu;
	TM_PAGE    *pPage;
	TM_ITEM    *pItem;

	if (paramNum == 1) {
		if (paramArray[0] == NVTEVT_KEY_PRESS) {
			pMenu = MenuCommonOption_GetCurrentMenu();
			pPage = &pMenu->pPages[pMenu->SelPage];
			pItem = &pPage->pItems[pPage->SelItem];

			pPage->SelItem++;
			//check item if disable
			TM_CheckItemStatus(pMenu, &pPage->SelItem, TRUE);

			if (pPage->SelItem == pPage->Count) {
				// Close current UI Window now
				Ux_CloseWindow(&MenuCommonOptionCtrl, 2, pItem->ItemId, 0);
			} else {
				MenuCommonOption_UpdateContent(pMenu);
				MenuCommonOption_UpdatePosition();
				Ux_SendEvent(pCtrl, NVTEVT_NEXT_ITEM, 0);
			}
		}
	}
	return NVTEVT_CONSUME;
}
INT32 MenuCommonOption_List_OnKeyPrev(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	TM_MENU    *pMenu;
	TM_PAGE    *pPage;
	TM_ITEM    *pItem;

	if (paramNum == 1) {
		if (paramArray[0] == NVTEVT_KEY_PRESS) {
			pMenu = MenuCommonOption_GetCurrentMenu();
			pPage = &pMenu->pPages[pMenu->SelPage];
			pItem = &pPage->pItems[pPage->SelItem];

			if (pPage->SelItem == 0) {
				// Close current UI Window now
				Ux_CloseWindow(&MenuCommonOptionCtrl, 2, pItem->ItemId, 0);
			} else {
				pPage->SelItem--;
				//check item if disable
				TM_CheckItemStatus(pMenu, &pPage->SelItem, FALSE);
				if (pPage->SelItem == pPage->Count) {
					// Close current UI Window now
					Ux_CloseWindow(&MenuCommonOptionCtrl, 2, pItem->ItemId, 0);
				} else {
					MenuCommonOption_UpdateContent(pMenu);
					MenuCommonOption_UpdatePosition();
					Ux_SendEvent(pCtrl, NVTEVT_PREVIOUS_ITEM, 0);
				}
			}
		}
	}
	return NVTEVT_CONSUME;
}

INT32 MenuCommonOption_List_OnKeySelect(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	TM_MENU    *pMenu;
	TM_PAGE    *pPage;
	TM_ITEM    *pItem;
	TM_OPTION  *pOption;
	UINT16      SelOption = 0;

	if (paramNum == 1) {
		pMenu = MenuCommonOption_GetCurrentMenu();
		pPage = &pMenu->pPages[pMenu->SelPage];
		pItem = &pPage->pItems[pPage->SelItem];

		if (paramArray[0] == NVTEVT_KEY_PRESS) {
			if (pItem->Count != 0 && pItem->SysFlag != 0) {
				//#NT#2016/09/20#Bob Huang -begin
				//#NT#Support HDMI Display with 3DNR Out
				//Only support FHD p30 size, cannot change size when 3DNR Out enabled
#if (_3DNROUT_FUNC == ENABLE)
				if (pItem->SysFlag == FL_MOVIE_SIZE_MENU && gb3DNROut) {
					Ux_SendEvent(pCtrl, NVTEVT_PRESS, 0);
					return NVTEVT_CONSUME;
				}
#endif
				//#NT#2016/09/20#Bob Huang -end
				SelOption = SysGetFlag(pItem->SysFlag);
				pMenu->Status = TMS_ON_OPTION;
				SelOption++;
				if (SelOption >= pItem->Count) {
					SelOption = 0;
				}
				TM_CheckOptionStatus(pMenu, &SelOption, TRUE);

				SysSetFlag(pItem->SysFlag, SelOption);
				// notify upper layer the Option had been confirmed
				TM_MENU_CALLBACK(pMenu, TMM_CONFIRM_OPTION, MAKE_LONG(pItem->ItemId, SelOption));

				pOption = &pItem->pOptions[SysGetFlag(pItem->SysFlag)];
				if (pOption->TextId & STRID_USER_START) {
					UxMenu_SetItemData(&MenuCommonOption_StatusCtrl, 0, MNUITM_STRID,  Txt_Pointer(UIRes_GetUserString(pOption->TextId)));
				} else {
					UxMenu_SetItemData(&MenuCommonOption_StatusCtrl, 0, MNUITM_STRID,  pOption->TextId);
				}

				if (pItem->ItemId == IDM_LANGUAGE) {
					MenuCommonOption_UpdatePosition();
				}

				Ux_SendEvent(pCtrl, NVTEVT_PRESS, 0);
			} else if (pItem->pOptions != 0) {              // custom process
				pMenu->Status = TMS_ON_CUSTOM;
				TM_ITEM_CALLBACK(pItem, TMM_CONFIRM_OPTION, pItem->ItemId);              // execute custom pPage flow
			}

		} else if (paramArray[0] == NVTEVT_KEY_RELEASE) {
			if (pItem->Count != 0 && pItem->SysFlag != 0) { // standard process
				Ux_SendEvent(pCtrl, NVTEVT_RELEASE, 0);
			}
		}

	}
	return NVTEVT_CONSUME;
}

INT32 MenuCommonOption_List_OnKeyExit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	Ux_CloseWindow(&MenuCommonItemCtrl, 0);
	return NVTEVT_CONSUME;
}

//----------------------MenuCommonOption_TitleCtrl Event---------------------------
EVENT_BEGIN(MenuCommonOption_Title)
EVENT_END

//----------------------MenuCommonOption_StatusCtrl Event---------------------------
EVENT_BEGIN(MenuCommonOption_Status)
EVENT_END

//---------------------MenuCommOption_PanelCtrl Control List---------------------------
CTRL_LIST_BEGIN(MenuCommOption_Panel)
CTRL_LIST_ITEM(MenuCommonOption_Left)
CTRL_LIST_ITEM(MenuCommonOption_Right)
CTRL_LIST_ITEM(MenuCommonOption_LeftIcon)
CTRL_LIST_ITEM(MenuCommonOption_RightIcon)
CTRL_LIST_END

//----------------------MenuCommOption_PanelCtrl Event---------------------------
EVENT_BEGIN(MenuCommOption_Panel)
EVENT_END

//----------------------MenuCommonOption_LeftCtrl Event---------------------------
EVENT_BEGIN(MenuCommonOption_Left)
EVENT_END

//----------------------MenuCommonOption_RightCtrl Event---------------------------
EVENT_BEGIN(MenuCommonOption_Right)
EVENT_END

//----------------------MenuCommonOption_LeftIconCtrl Event---------------------------
EVENT_BEGIN(MenuCommonOption_LeftIcon)
EVENT_END

//----------------------MenuCommonOption_RightIconCtrl Event---------------------------
EVENT_BEGIN(MenuCommonOption_RightIcon)
EVENT_END

//----------------------MenuCommonOption_STA_TitleCtrl Event---------------------------
EVENT_BEGIN(MenuCommonOption_STA_Title)
EVENT_END

//---------------------MenuCommonOption_PNLCtrl Control List---------------------------
CTRL_LIST_BEGIN(MenuCommonOption_PNL)
CTRL_LIST_END

//----------------------MenuCommonOption_PNLCtrl Event---------------------------
EVENT_BEGIN(MenuCommonOption_PNL)
EVENT_END

//----------------------MenuCommonOption_MNU_SelectionCtrl Event---------------------------
INT32 MenuCommonOption_MNU_Selection_OnTouchPanelPress(VControl *, UINT32, UINT32 *);
INT32 MenuCommonOption_MNU_Selection_OnTouchPanelRelease(VControl *, UINT32, UINT32 *);
INT32 MenuCommonOption_MNU_Selection_OnTouchPanelMove(VControl *, UINT32, UINT32 *);
INT32 MenuCommonOption_MNU_Selection_OnTouchPanelClick(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(MenuCommonOption_MNU_Selection)
EVENT_ITEM(NVTEVT_PRESS,MenuCommonOption_MNU_Selection_OnTouchPanelPress)
EVENT_ITEM(NVTEVT_RELEASE,MenuCommonOption_MNU_Selection_OnTouchPanelRelease)
EVENT_ITEM(NVTEVT_MOVE,MenuCommonOption_MNU_Selection_OnTouchPanelMove)
EVENT_ITEM(NVTEVT_CLICK,MenuCommonOption_MNU_Selection_OnTouchPanelClick)
EVENT_END

INT32 MenuCommonOption_MNU_Selection_OnTouchPanelPress(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

    // Store pressed coordinate and current item for move event calculation
    g_MenuMoved = FALSE;
    g_TouchPressX = paramArray[0];
    g_TouchPressY = paramArray[1];
    g_PressedItem = UxMenu_GetData(pCtrl, MNU_CURITM);
	
    // Do not trigger default press event in UICtrlMenuLib
    return NVTEVT_CONSUME;
}

INT32 MenuCommonOption_MNU_Selection_OnTouchPanelRelease(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // Do not trigger default release event in UICtrlMenuLib
    return NVTEVT_CONSUME;
}

INT32 MenuCommonOption_MNU_Selection_OnTouchPanelMove(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    //INT32 uiPosX;
    INT32 uiPosY;
    INT32 CurrItem;
    INT32 TatalItem;
    INT32 ItemOffset;
    g_MenuMoved = TRUE;
    //uiPosX = paramArray[0];
    uiPosY = paramArray[1];

    // check whether the move point is in the menu range
    if ((uiPosY > Menu_rect.y1) && uiPosY < (Menu_rect.y1 + 5 * (Menu_rect.y2-Menu_rect.y1))) {
        // Calculate how many option range is crossed
        ItemOffset = (uiPosY - g_TouchPressY) / (Menu_rect.y2-Menu_rect.y1);

        if (ItemOffset) {
            TatalItem = UxMenu_GetData(pCtrl, MNU_TOTITM);
            CurrItem = g_PressedItem - ItemOffset;
            // Check whether the target option is in valid range
            if (CurrItem >= PRE_DUMMY_ITEM && CurrItem < TatalItem) {
                UxMenu_SetData(pCtrl, MNU_CURITM, CurrItem);
                UxCtrl_SetDirty(&MenuCommonOption_PNLCtrl, TRUE);
                Ux_Redraw();
            }
        }
    }
    // Flush repeat NVTEVT_MOVE in event queue
    Ux_FlushEventByRange(NVTEVT_MOVE, NVTEVT_MOVE);

    // Do not trigger default move event in UICtrlMenuLib
    return NVTEVT_CONSUME;
}

INT32 MenuCommonOption_MNU_Selection_OnTouchPanelClick(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    //INT32 uiPosX;
    INT32 uiPosY;
    INT32 CurrItem;
    INT32 TatalItem;
    INT32 ItemOffset;
	
    if (g_MenuMoved == FALSE) {
        //uiPosX = paramArray[0];
        uiPosY = paramArray[1];

        ItemOffset = ((uiPosY - Menu_rect.y1) / (Menu_rect.y2-Menu_rect.y1)) - 2;
        if (ItemOffset) {
            TatalItem = UxMenu_GetData(pCtrl, MNU_TOTITM);
            CurrItem = UxMenu_GetData(pCtrl, MNU_CURITM);
            CurrItem = g_PressedItem + ItemOffset;
            // Check whether the target option is in valid range
            if (CurrItem >= PRE_DUMMY_ITEM && CurrItem < TatalItem) {
                UxMenu_SetData(pCtrl, MNU_CURITM, CurrItem);
                UxCtrl_SetDirty(&MenuCommonOption_PNLCtrl, TRUE);
                Ux_Redraw();
            }
        }
    }
    return NVTEVT_CONSUME;
}
//----------------------MenuCommonOption_BTN_OKCtrl Event---------------------------
INT32 MenuCommonOption_BTN_OK_OnTouchPanelClick(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(MenuCommonOption_BTN_OK)
EVENT_ITEM(NVTEVT_CLICK,MenuCommonOption_BTN_OK_OnTouchPanelClick)
EVENT_END

INT32 MenuCommonOption_BTN_OK_OnTouchPanelClick(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    TM_MENU*    pMenu;
    TM_PAGE*    pPage;
    TM_ITEM*    pItem;
    UINT16      SelOption = 0;

    // Get menu/page/item
    pMenu = MenuCommonOption_GetCurrentMenu();
    pPage = &pMenu->pPages[pMenu->SelPage];
    pItem = &pPage->pItems[pPage->SelItem];

    // Save the option
    if (pItem->SysFlag) {
        // Remap select option to real one
        SelOption = ItemReMap[UxMenu_GetData(&MenuCommonOption_MNU_SelectionCtrl, MNU_CURITM)];
        SysSetFlag(pItem->SysFlag,SelOption);
        TM_MENU_CALLBACK(pMenu, TMM_CONFIRM_OPTION, MAKE_LONG(pItem->ItemId, SelOption));
    }
    Ux_CloseWindow (&MenuCommonOptionCtrl, 0);
    return NVTEVT_CONSUME;
}
//----------------------MenuCommonOption_BTN_CancelCtrl Event---------------------------
INT32 MenuCommonOption_BTN_Cancel_OnTouchPanelClick(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(MenuCommonOption_BTN_Cancel)
EVENT_ITEM(NVTEVT_CLICK,MenuCommonOption_BTN_Cancel_OnTouchPanelClick)
EVENT_END

INT32 MenuCommonOption_BTN_Cancel_OnTouchPanelClick(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    // Just close window without save option
    Ux_CloseWindow (&MenuCommonOptionCtrl, 0);
    return NVTEVT_CONSUME;
}
